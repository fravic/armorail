package septenary.duelparty {    import flash.events.EventDispatcher;    import flash.geom.Point;    import flash.display.Sprite;    public class TrainCarMovement extends EventDispatcher {        protected var _display:Sprite;        protected var _manager:TrainCarManager;        protected var _carAhead:TrainCarMovement;        protected var _carBehind:TrainCarMovement;        protected var _tugPtAhead:Point = new Point(4, 0);        protected var _tugPtBehind:Point = new Point(-4, 0);        protected var _tugDistBehind:Number = 40;        protected var _targetPt:Point;        protected var _targetRot:Number = 0;        protected var _pulleyQueue:Array = new Array();        protected var _targetReachedCallback:Function;        protected var _speed:Number = 8;        public function get carAhead():TrainCarMovement {            return _carAhead;        }        public function set carAhead(value:TrainCarMovement):void {            _carAhead = value;        }        public function get carBehind():TrainCarMovement {            return _carBehind;        }        public function set carBehind(value:TrainCarMovement):void {            _carBehind = value;        }        public function get tugDistBehind():Number {            return _tugDistBehind;        }        public function set tugDistBehind(value:Number):void {            _tugDistBehind = value;        }        public function get display():Sprite {            return _display;        }        public function get manager():TrainCarManager {            return _manager;        }        public function set manager(value:TrainCarManager):void {            _manager = value;        }        public function TrainCarMovement(display:Sprite) {            super();            _display = display;            _targetPt = new Point(_display.x, _display.y);        }        public function tugPointGlobal(front:Boolean):Point {            var localPt:Point = front ? _tugPtAhead : _tugPtBehind;            var localDist:Number = Point.distance(localPt, new Point());            var localAngle:Number = Math.atan2(localPt.y, localPt.x);            var globalAngle:Number = localAngle + _display.rotation * Math.PI / 180;            return new Point(_display.x + localDist * Math.cos(globalAngle),                             _display.y + localDist * Math.sin(globalAngle));        }        public function insertCar(car:TrainCarMovement, inFront:Boolean):void {            if (inFront) {                var oldCarAhead:TrainCarMovement = _carAhead;                coupleCar(car, true);                if (oldCarAhead != null) {                    oldCarAhead.coupleCar(car, false);                }            } else {                var oldCarBehind:TrainCarMovement = _carBehind;                coupleCar(car, false);                if (oldCarBehind != null) {                    oldCarBehind.coupleCar(car, true);                }            }        }        protected function coupleCar(car:TrainCarMovement, inFront:Boolean):void {            if (inFront) {                _carAhead = car;                car.carBehind = this;            } else {                _carBehind = car;                car.carAhead = this;            }        }        public function pushPulley(pt:Point):void {            _pulleyQueue.push(pt);        }        public function moveTo(pt:Point, callback:Function=null):void {            Utilities.assert(_carAhead == null, "Can't move train car that isn't at front!");            _targetPt = pt;            _targetReachedCallback = callback;        }        public function reverseEntireTrain():void {            //TODO: Implement this!        }        public function swapSurroundingCars():void {            //TODO: Implement this!        }        public function teleportTo(pt:Point):void {            _targetPt = pt;            _display.x = _targetPt.x;            _display.y = _targetPt.y;        }                public function update():void {            if (_carAhead == null) {                moveToTarget();            } else {                constrainToCarAhead();            }        }        protected function moveToTarget() {            const distMin:Number = 0.1;            const rotMin:Number = 0.01;            const rotDivider:Number = 3;            if (_targetPt != null) {                var dist:Number = Point.distance(_targetPt, new Point(_display.x, _display.y));                if (dist <= distMin) {                    if (_carBehind) _carBehind.pushPulley(tugPointGlobal(false));                    _targetPt = null;                    var callback:Function = _targetReachedCallback;                    _targetReachedCallback = null;                    if (callback != null) callback();                    return;                }                var moveDist:Number = _speed;                if (moveDist > dist) moveDist = dist;                var moveAngle:Number = Math.atan2((_targetPt.y - _display.y), (_targetPt.x - _display.x));                _display.x += Math.cos(moveAngle) * moveDist;                _display.y += Math.sin(moveAngle) * moveDist;                _targetRot = moveAngle;            }            var radRot:Number = _display.rotation * (Math.PI/180);            if (Math.abs(_targetRot - radRot) > rotMin) {                _display.rotation += (Utilities.angleDiff(_targetRot, radRot) *                                    Utilities.shortRotation(radRot, _targetRot)                                    / rotDivider) * (180/Math.PI);            }        }        protected function constrainToCarAhead():void {            Utilities.assert(_carAhead != null, "Attempt to constrain to null car ahead!");            /*The train constraints have a set of rules, where i, j are constants:                1. The tug point is at i distance from the center of the display                2. The tug point is no more than k distance from the tug point ahead                3. If at all possible, the display should rotate to satisfy the above rules            */            const glbTugAhead:Point = _carAhead.tugPointGlobal(false);            const glbTugLocal:Point = tugPointGlobal(true);            const tugDisplayAngle:Number = Math.atan2((glbTugAhead.y - _display.y), (glbTugAhead.x - _display.x));            const tugFaceAngle:Number = Math.atan2(_tugPtAhead.y, _tugPtAhead.x);            const localTugDist:Number = Point.distance(new Point(_display.x, _display.y), glbTugLocal);            const targFaceAngle:Number = tugDisplayAngle + tugFaceAngle;            const arcDist:Number = localTugDist * Utilities.angleDiff(targFaceAngle, _display.rotation * Math.PI/180);            var curTugDist:Number;            const nextPulley:Point = _pulleyQueue[0];            if (nextPulley != null) {                curTugDist = Point.distance(nextPulley, glbTugLocal) +                              Point.distance(glbTugAhead, nextPulley) + arcDist;            } else {                curTugDist = Point.distance(glbTugAhead, glbTugLocal) + arcDist;            }            if (curTugDist > _carAhead.tugDistBehind) {				var moveBy:Number = curTugDist - _carAhead.tugDistBehind;                var newArcDist:Number = arcDist - moveBy;                var moveDist:Number, moveArcDist:Number;                if (newArcDist < 0) {                    moveDist = -newArcDist;                    moveArcDist = moveBy - moveDist;                } else {                    moveDist = 0;                    moveArcDist = moveBy;                }                if (localTugDist != 0) {                    _display.rotation += (180/Math.PI) * (moveArcDist / localTugDist) *                                         Utilities.shortRotation(_display.rotation * Math.PI/180, targFaceAngle);                }                var moveAngle:Number;                if (nextPulley != null) {                    moveAngle = Math.atan2((nextPulley.y - glbTugLocal.y), (nextPulley.x - glbTugLocal.x));                } else {                    moveAngle = Math.atan2((glbTugAhead.y - glbTugLocal.y), (glbTugAhead.x - glbTugLocal.x));                }                _display.x += Math.cos(moveAngle) * moveDist;                _display.y += Math.sin(moveAngle) * moveDist;                if (nextPulley != null) {                    if (Point.distance(glbTugLocal, nextPulley) < _speed) {                        _pulleyQueue.shift();                        if (_carBehind) _carBehind.pushPulley(nextPulley);                    }                }            }        }    }}