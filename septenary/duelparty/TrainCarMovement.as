package septenary.duelparty {    import flash.events.EventDispatcher;    import flash.geom.Point;    import flash.display.Sprite;    import com.greensock.TweenLite;    public class TrainCarMovement extends EventDispatcher {        public static const STATE_ENABLED:int = 0;        public static const STATE_DISABLED:int = 1;        public static const STATE_ROTATE_ONLY:int = 3;        protected var _display:Sprite;        protected var _manager:TrainCarManager;        protected var _carAhead:TrainCarMovement;        protected var _carBehind:TrainCarMovement;        protected var _tugPtAhead:Point = new Point(4, 0);        protected var _tugPtBehind:Point = new Point(-4, 0);        protected var _tugDistBehind:Number = 40;        protected var _state:int = STATE_ENABLED;        protected var _targetPt:Point;        protected var _targetRot:Number = 0;        protected var _pulleyQueue:Array = new Array();        protected var _targetReachedCallback:Function;        protected var _speed:Number = 8;        public function get carAhead():TrainCarMovement {            return _carAhead;        }        public function set carAhead(value:TrainCarMovement):void {            _carAhead = value;        }        public function get carBehind():TrainCarMovement {            return _carBehind;        }        public function set carBehind(value:TrainCarMovement):void {            _carBehind = value;        }        public function get tugDistBehind():Number {            return _tugDistBehind;        }        public function set tugDistBehind(value:Number):void {            _tugDistBehind = value;        }        public function get display():Sprite {            return _display;        }        public function get manager():TrainCarManager {            return _manager;        }        public function set manager(value:TrainCarManager):void {            _manager = value;        }        public function get state():int {            return _state;        }        public function set state(value:int):void {            _state = value;        }        public function TrainCarMovement(display:Sprite) {            super();            _display = display;            _targetPt = new Point(_display.x, _display.y);        }        public function tugPointGlobal(front:Boolean):Point {            var localPt:Point = front ? _tugPtAhead : _tugPtBehind;            var localDist:Number = Point.distance(localPt, new Point());            var localAngle:Number = Math.atan2(localPt.y, localPt.x);            var globalAngle:Number = localAngle + _display.rotation * Math.PI / 180;            return new Point(_display.x + localDist * Math.cos(globalAngle),                             _display.y + localDist * Math.sin(globalAngle));        }        public function insertCar(car:TrainCarMovement, inFront:Boolean):void {            if (inFront) {                var oldCarAhead:TrainCarMovement = _carAhead;                coupleCar(car, true);                if (oldCarAhead != null) {                    oldCarAhead.coupleCar(car, false);                }            } else {                var oldCarBehind:TrainCarMovement = _carBehind;                coupleCar(car, false);                if (oldCarBehind != null) {                    oldCarBehind.coupleCar(car, true);                }            }        }        public function switchSurroundingCars():void {            //Makes the foreguard the rearguard, and vice-versa            var carAheadLinks:Object = _carAhead != null ? {ahead:_carAhead.carAhead, behind:_carAhead.carBehind}                                                         : {ahead:null,  behind:this};            var carBehindLinks:Object = _carBehind != null ? {ahead:_carBehind.carAhead, behind:_carBehind.carBehind}                                                         : {ahead:this, behind:null};            var carAhead:TrainCarMovement = _carAhead;            if (_carBehind != null) {                _carBehind.carAhead = carAheadLinks.ahead;                _carBehind.carBehind = carAheadLinks.behind;            }            if (_carAhead != null) {                _carAhead.carAhead = carBehindLinks.ahead;                _carAhead.carBehind = carBehindLinks.behind;            }            _carAhead = _carBehind;            _carBehind = carAhead;        }        protected function coupleCar(car:TrainCarMovement, inFront:Boolean):void {            if (inFront) {                _carAhead = car;                car.carBehind = this;            } else {                _carBehind = car;                car.carAhead = this;            }        }        public function pushPulley(pt:Point):void {            _pulleyQueue.push(pt);        }        public function pushPulleyBack():void {            if (_carBehind) _carBehind.pushPulley(tugPointGlobal(false));        }        protected function passPulleyOn():void {            var nextPulley:Point = _pulleyQueue.shift();            if (_carBehind) _carBehind.pushPulley(nextPulley);        }        public function moveTo(pt:Point, callback:Function=null):void {            Utilities.assert(_carAhead == null, "Can't move train car that isn't at front!  ("+_carAhead+").");            _targetPt = pt;            _targetReachedCallback = callback;        }        protected function targetReachedCallback():void {            //It is important to clear the callback before calling it, or stack overflow could occur            var callback:Function = _targetReachedCallback;            _targetReachedCallback = null;            if (callback != null) callback();        }        public function cancelMove():void {            _targetPt = new Point(_display.x, _display.y);            if (_targetReachedCallback != null) {                targetReachedCallback();            }        }        public function rotateToFaceCarAhead():void {            Utilities.assert(_carAhead != null, "Can't face null car ahead!");            const glbTugAhead:Point = _carAhead.tugPointGlobal(false);            const tugDisplayAngle:Number = Math.atan2((glbTugAhead.y - _display.y), (glbTugAhead.x - _display.x));            const tugFaceAngle:Number = Math.atan2(_tugPtAhead.y, _tugPtAhead.x);            const targFaceAngle:Number = tugDisplayAngle + tugFaceAngle;                        _targetRot = Utilities.normalizeRadAngle(targFaceAngle);            _state = STATE_ROTATE_ONLY;            cancelMove();        }        public function faceOppositeDirection():void {            _targetRot = (_display.rotation * (Math.PI/180)) + Math.PI;            _targetRot = Utilities.normalizeRadAngle(_targetRot);            _state = STATE_ROTATE_ONLY;            cancelMove();        }        public function teleportTo(pt:Point):void {            _targetPt = pt;            _display.x = _targetPt.x;            _display.y = _targetPt.y;        }                public function update():void {            if (_state == STATE_DISABLED) return;             if (_state == STATE_ROTATE_ONLY) {                rotateToTarget();            } else if (_carAhead == null) {                moveToTarget();                rotateToTarget();            } else {                constrainToCarAhead();            }        }        protected function moveToTarget():void {            const distMin:Number = 0.1;            if (_targetPt != null) {                var dist:Number = Point.distance(_targetPt, new Point(_display.x, _display.y));                if (dist <= distMin) {                    _targetPt = null;                    targetReachedCallback();                    return;                }                var moveDist:Number = _speed;                if (moveDist > dist) moveDist = dist;                var moveAngle:Number = Math.atan2((_targetPt.y - _display.y), (_targetPt.x - _display.x));                _display.x += Math.cos(moveAngle) * moveDist;                _display.y += Math.sin(moveAngle) * moveDist;                _targetRot = Utilities.normalizeRadAngle(moveAngle);            }        }        protected function rotateToTarget():void {            const rotMin:Number = 0.01;            const rotDivider:Number = 3;                        var radRot:Number = Utilities.normalizeRadAngle(_display.rotation * (Math.PI/180));            if (Math.abs(_targetRot - radRot) > rotMin) {                _display.rotation += (Utilities.angleDiff(_targetRot, radRot) *                                    Utilities.shortRotation(radRot, _targetRot)                                    / rotDivider) * (180/Math.PI);            } else if (_state == STATE_ROTATE_ONLY) _state = STATE_ENABLED;        }        protected function constrainToCarAhead():void {            Utilities.assert(_carAhead != null, "Attempt to constrain to null car ahead!");            /*The train constraints have a set of rules, where i, j are constants:                1. The tug point is at i distance from the center of the display                2. The tug point is no more than k distance from the tug point ahead                3. If at all possible, the display should rotate to satisfy the above rules            */            const glbTugAhead:Point = _carAhead.tugPointGlobal(false);            const glbTugLocal:Point = tugPointGlobal(true);            const tugDisplayAngle:Number = Math.atan2((glbTugAhead.y - _display.y), (glbTugAhead.x - _display.x));            const tugFaceAngle:Number = Math.atan2(_tugPtAhead.y, _tugPtAhead.x);            const localTugDist:Number = Point.distance(new Point(_display.x, _display.y), glbTugLocal);            const targFaceAngle:Number = tugDisplayAngle + tugFaceAngle;            const arcDist:Number = localTugDist * Utilities.angleDiff(targFaceAngle, _display.rotation * Math.PI/180);            var curTugDist:Number;            const nextPulley:Point = _pulleyQueue[0];            if (nextPulley != null) {                curTugDist = Point.distance(nextPulley, glbTugLocal) +                              Point.distance(glbTugAhead, nextPulley) + arcDist;            } else {                curTugDist = Point.distance(glbTugAhead, glbTugLocal) + arcDist;            }            if (curTugDist > _carAhead.tugDistBehind) {				var moveBy:Number = curTugDist - _carAhead.tugDistBehind;                moveBy = claimMovementForArcDist(moveBy, arcDist, localTugDist, targFaceAngle);                moveBy = claimMovementForPulley(moveBy, nextPulley, glbTugLocal);                finalMovementForTug(moveBy, glbTugLocal, glbTugAhead);            }        }        private function claimMovementForArcDist(moveBy:Number, arcDist:Number,                                                 localTugDist:Number, targFaceAngle:Number):Number {            Utilities.assert(localTugDist != 0, "Local tug point cannot be at origin!");            var distRemaining:Number = 0;            var newArcDist:Number = arcDist - moveBy;            if (newArcDist < 0) {                moveBy += newArcDist;                distRemaining = -newArcDist;            }            var radRot:Number = Utilities.normalizeRadAngle(_display.rotation * Math.PI/180);            var normFace:Number = Utilities.normalizeRadAngle(targFaceAngle);            _display.rotation += (180/Math.PI) * (moveBy / localTugDist) *                                 Utilities.shortRotation(radRot, normFace);            return distRemaining;        }        private function claimMovementForPulley(moveBy:Number, nextPulley:Point, glbTugLocal:Point):Number {            if (nextPulley == null) {                return moveBy;            }            var distRemaining:Number = 0;            var distToPulley:Number = Point.distance(glbTugLocal, nextPulley);            var newDistToPulley:Number = distToPulley - moveBy;            if (newDistToPulley <= 0) {                moveBy += newDistToPulley;                distRemaining = -newDistToPulley;                passPulleyOn();            }            var moveAngle:Number = Math.atan2((nextPulley.y - glbTugLocal.y), (nextPulley.x - glbTugLocal.x));            _display.x += Math.cos(moveAngle) * moveBy;            _display.y += Math.sin(moveAngle) * moveBy;            return distRemaining;        }        private function finalMovementForTug(moveBy:Number, glbTugLocal:Point, glbTugAhead:Point):void {            var moveAngle:Number = Math.atan2((glbTugAhead.y - glbTugLocal.y), (glbTugAhead.x - glbTugLocal.x));            _display.x += Math.cos(moveAngle) * moveBy;            _display.y += Math.sin(moveAngle) * moveBy;        }    }}