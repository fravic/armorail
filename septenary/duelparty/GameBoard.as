package septenary.duelparty {    import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.Point;    import flash.utils.getDefinitionByName;	public class GameBoard extends Sprite {				protected static var activeBoard:GameBoard;				//Board properties        protected var _envVars:Object;		protected var _gameOver:Boolean = false;		protected var _numPlayers:int = 0;		protected var _defaultCoins:int = 100;		protected var _defaultHealth:int = 10;				//Board elements		protected var _players:Array = new Array();		protected var _playerDatas:Array = new Array();		protected var _deadPlayers:int = 0;        protected var _lastDeath:Player;		protected var _boardTiles:Array = new Array();        protected var _updateables:Array = new Array();        //Layers		protected var _background:Sprite;		protected var _backgroundOver:Sprite = new Sprite();        protected var _field:Sprite = new Sprite();        protected var _overlay:Sprite = new Sprite();				//Game state		protected var _gameScreen:GameScreen;		protected var _turnOrder:Array = new Array();        protected var _turnStartEvents:Array = new Array();        protected var _turnEndEvents:Array = new Array();		protected var _curTurnIndex:int = 0;				public function get gameScreen():GameScreen {			return _gameScreen;		}		public function get background():Sprite {			return _background;		}        public function get field():Sprite {            return _field;        }		public function get gameOver():Boolean {			return _gameOver;		}        public function get players():Array {            return _players;        }				public static function getGameBoard():GameBoard {            return activeBoard;		}				public function GameBoard(gameScreen:GameScreen) {			_gameScreen = gameScreen;			super();		}				public function initBoard(boardType:String, playerDatas:Array):void {			GameBoard.activeBoard = this;			_playerDatas = playerDatas;            GameEvent.addOneTimeEventListener(BoardLoader.getBoardLoader(), GameEvent.ACTION_COMPLETE, boardLoaded);            BoardLoader.getBoardLoader().loadBoard(boardType);		}		public function update():void {			var curPlayer:Player = curTurnPlayer();			if (curPlayer) {				_gameScreen.setCameraTarget(new Point(curPlayer.x, curPlayer.y));			}			for (var i:int = 0; i < _updateables.length; i++) {				_updateables[i].update();			}            setFieldChildIndicies();		}        public function addUpdateable(obj:Object):void {            _updateables.push(obj);            }        public function removeUpdateable(obj:Object):void {            _updateables.splice(_updateables.indexOf(obj), 1);        }				protected function boardLoaded(e:GameEvent):void {			//Load and display board			_boardTiles = e.data.boardTiles;            _envVars = e.data.envVars;			initPlayers();						_background = Utilities.classInstanceFromString(_envVars.background + "Background");			addChild(_background);			addChild(_backgroundOver);            addChild(_field);            addChild(_overlay);			drawTileConnectors();			addBoardElements(_boardTiles, true);            addBoardElements(e.data.embellishments);            for (var i:int = 0; i < _boardTiles.length; i++) {                _boardTiles[i].setup();                }            CONFIG::DEBUG {                _turnOrder = [0, 1];                _curTurnIndex = -1;                teleportPlayersOntoBoard();                return;            }            CONFIG::RELEASE {                showMapOverview();                return;            }            Utilities.assert(false, "Set either the 'DEBUG' or 'RELEASE' flag in your compiler settings");		}				protected function initPlayers():void {			for (var i:int = 0; i < _playerDatas.length; i++) {				//Init player and add to correct tile				var newPlayer:Player = new Player();                newPlayer.setPlayerData(_playerDatas[i]);				newPlayer.coins = _defaultCoins;				newPlayer.health = newPlayer.maxHealth = _defaultHealth;				GameEvent.addOneTimeEventListener(newPlayer, GameEvent.PLAYER_DIED, playerKilled);                _updateables.push(newPlayer);				_players.push(newPlayer);			}		}        public function addChildToBackground(c:DisplayObject):void {            _background.addChild(c);        }        public function removeChildFromBackground(c:DisplayObject):void {            _background.removeChild(c);        }        public function addChildToField(c:DisplayObject):void {            _field.addChild(c);			setFieldChildIndicies();        }        public function removeChildFromField(c:DisplayObject):void {            _field.removeChild(c);        }        public function addChildToOverlay(c:DisplayObject):void {            _overlay.addChild(c);        }        public function removeChildFromOverlay(c:DisplayObject):void {            _overlay.removeChild(c);        }				protected function addBoardElements(elements:Array, onBG:Boolean=false):void {			var container:Sprite = onBG ? _backgroundOver : _field;            for (var i:int = 0; i < elements.length; i++) {				container.addChild(elements[i]);			}		}				protected function drawTileConnectors():void {			_backgroundOver.graphics.lineStyle(3, 0x0, 0.65);			for (var i:int = 0; i < _boardTiles.length; i++) {				var bT:BoardTile = _boardTiles[i];				for (var j:int = 0; j < bT.tilesOut.length; j++) {					var bTO:BoardTile = bT.tilesOut[j];					_backgroundOver.graphics.moveTo(bT.x, bT.y);					_backgroundOver.graphics.lineTo(bTO.x, bTO.y);				}			}		}        protected function showMapOverview():void {            const overviewZoom:Number = 0.5;            _gameScreen.setCameraZoom(overviewZoom, true);            _gameScreen.setCameraTarget(new Point(_background.width/2, _background.height/2));            GameEvent.addOneTimeEventListener(GameInterface.getGameInterface(), GameEvent.ACTION_COMPLETE,                                              mapOverviewDone);            GameInterface.getGameInterface().playBoardIntro({boardName:_envVars.name, players:_players});            //mapOverviewDone();        }        protected function mapOverviewDone(e:GameEvent=null):void {            determineTurnOrder();        }        protected function determineTurnOrder():void {            var turnOrderSelection:TurnOrderSelection = new TurnOrderSelection(_players);            GameEvent.addOneTimeEventListener(turnOrderSelection, GameEvent.ACTION_COMPLETE, turnOrderDetermined);            _gameScreen.pushSuperScreen(turnOrderSelection);        }        protected function turnOrderDetermined(e:GameEvent):void {            _gameScreen.dismissSuperScreen(e.target as Screen);            _curTurnIndex = -1;            _turnOrder = e.data.turnOrder;            function transitionHalfway(e:GameEvent):void {                 GameScreen.getGameScreen().setCameraZoom(1, true);            }            var blackTrans:BlackTransition = BlackTransition.getBlackTransition();            GameEvent.addOneTimeEventListener(blackTrans, GameEvent.SCREEN_TRANSITIONED, transitionHalfway);            GameEvent.addOneTimeEventListener(blackTrans, GameEvent.ACTION_COMPLETE, teleportPlayersOntoBoard);            blackTrans.transition(BlackTransition.TRANSITION_SHAPE_CIRCLE, BlackTransition.TRANSITION_SHAPE_CIRCLE);        }        protected function teleportPlayersOntoBoard(e:GameEvent=null):void {            nextPlayerTeleportOntoBoard();        }        protected function nextPlayerTeleportOntoBoard(e:GameEvent=null):void {            _curTurnIndex++;            if (_curTurnIndex < _players.length) {                var thisPlayer:Player = curTurnPlayer();                GameEvent.addOneTimeEventListener(thisPlayer, GameEvent.ACTION_COMPLETE,                                                  nextPlayerTeleportOntoBoard);                thisPlayer.teleportToTile(_envVars.startPositions[_curTurnIndex]);			    GameInterface.getGameInterface().addPlayerInterface(_players[_turnOrder[_curTurnIndex]]);            } else {                initialFighterShopping();            }        }		protected function initialFighterShopping(e:GameEvent=null):void {            _curTurnIndex = -1;            nextPlayerShop();		}        protected function nextPlayerShop(e:GameEvent=null):void {            _curTurnIndex++;            if (_curTurnIndex < _players.length) {                var thisPlayer:Player = curTurnPlayer();                GameEvent.addOneTimeEventListener(thisPlayer, GameEvent.ACTION_COMPLETE, nextPlayerShop);                thisPlayer.shopForFighter();            } else {                preGameSetupComplete();            }        }        protected function preGameSetupComplete():void {            _curTurnIndex = 0;            nextTurn();        }				public function curTurnPlayer():Player {			return _players[_turnOrder[_curTurnIndex]];		}				protected function nextTurn(lastTurnPlayer:Player=null):void {			var thisTurnPlayer:Player = curTurnPlayer();            executeTurnEvent(_turnStartEvents);			dispatchEvent(new GameEvent(GameEvent.START_TURN, {player:thisTurnPlayer}));            GameEvent.addOneTimeEventListener(GameInterface.getGameInterface(), GameEvent.ACTION_COMPLETE, startNewTurn);            GameInterface.getGameInterface().playTurnStartNotice(thisTurnPlayer.playerData.name,                                                                 thisTurnPlayer.playerData.color);		}        protected function startNewTurn(e:GameEvent):void {            var thisTurnPlayer:Player = curTurnPlayer();            GameEvent.addOneTimeEventListener(thisTurnPlayer, GameEvent.ACTION_COMPLETE, startDiceRoll);			thisTurnPlayer.takeUpkeepAndStartTurn();        }				public function endTurn():void {			var thisTurnPlayer:Player = curTurnPlayer();            executeTurnEvent(_turnEndEvents);			dispatchEvent(new GameEvent(GameEvent.END_TURN, {player:thisTurnPlayer}));						_curTurnIndex = (_curTurnIndex + 1) % _players.length;			while(curTurnPlayer().dead) {				_curTurnIndex = (_curTurnIndex + 1) % _players.length;			}						nextTurn(thisTurnPlayer);		}        public function playerTurnsFromNow(player:Player, playerTurns:int):int {            var playerTurnIndex:int = _turnOrder.indexOf(player);            if (_curTurnIndex == playerTurnIndex) {                return _turnOrder.length * playerTurns;            } else if (_curTurnIndex > playerTurnIndex) {                return _turnOrder.length - (_curTurnIndex - playerTurnIndex) + _turnOrder.length * (playerTurns - 1);            } else {                return playerTurnIndex - _curTurnIndex + _turnOrder.length * (playerTurns - 1);            }        }        public function scheduleTurnEvent(callback:Function, data:Object, turnsAhead:Number, endOfTurn:Boolean):void {            var arrayRef:Array = endOfTurn ? _turnEndEvents : _turnStartEvents;            if (!arrayRef[turnsAhead]) {                arrayRef[turnsAhead] = new Array();            }            arrayRef[turnsAhead].push({callback:callback, data:data});        }        protected function executeTurnEvent(arrayRef:Array):void {            var events:Array = arrayRef.shift();            if (!events) return;            for (var i:int = 0; i < events.length; i++) {                events[i].callback(events[i].data);            }        }				protected function startDiceRoll(e:GameEvent=null):void {            var diceRoll:DiceRoll = new DiceRoll(curTurnPlayer());            diceRoll.addEventListener(GameEvent.ACTION_COMPLETE, endDiceRoll);			_gameScreen.pushAndSnapSuperScreen(diceRoll);		}				protected function endDiceRoll(e:GameEvent):void {            var rollResult:int = e.data.roll;			_gameScreen.dismissSuperScreen(e.target as Screen);			curTurnPlayer().movement.move(rollResult);		}				protected function playerKilled(e:GameEvent):void {			var p:Player = e.data as Player;			if (p.foreGuard) {				_field.removeChild(p.foreGuard);			}			if (p.rearGuard) {				_field.removeChild(p.rearGuard);			}			_field.removeChild(p);			GameInterface.getGameInterface().updatePlayerInterface(p);						_deadPlayers++;            _lastDeath = p;		}        //Returns true if there is a possibility of the game being over		public function checkForGameEnd():Boolean {            if (_lastDeath != null) {                if (_lastDeath.playerData.inputSource == NetScreen.PLAYER_INPUT) {                    showEndGameForPlayer(_lastDeath, false);                } else if (_deadPlayers == _players.length - 1) {                    for (var i:int = 0; i < _players.length; i++) {                        if (!_players[i].dead && (_players[i] as Player).playerData.inputSource ==                                                 NetScreen.PLAYER_INPUT) {                            showEndGameForPlayer(_players[i], true);                        }                    }                    _gameOver = true;                }                _lastDeath = null;                return true;            } else {                dispatchEvent(new GameEvent(GameEvent.GAME_NOT_OVER));                return false;            }		}				protected function showEndGameForPlayer(player:Player, victory:Boolean):void {            var extro:BoardExtro = new BoardExtro(player, _players, victory);            GameEvent.addOneTimeEventListener(extro, GameEvent.ACTION_COMPLETE, endGameForPlayerDone);            _gameScreen.pushSuperScreen(extro);        }        protected function endGameForPlayerDone(e:GameEvent):void {            dispatchEvent(new GameEvent(GameEvent.GAME_NOT_OVER));            }        protected function setFieldChildIndicies():void {            var children:Array = new Array();            for (var i:int = 0; i < _field.numChildren; i++) {                children.push(_field.getChildAt(i));            }            children.sortOn(["y", "name"]);            for (i = 0; i < children.length; i++) {                _field.setChildIndex(children[i], i);            }        }				public function gainedFocus():void {			}				public function lostFocus():void {		}	}}