package septenary.duelparty {	import com.greensock.*;	import com.greensock.easing.*;	import septenary.duelparty.boardtiles.BaseTile;	import flash.display.Sprite;	import flash.geom.Point;	public class Player extends Sprite3D implements Fightable {		protected var _playerData:PlayerData;		protected var _coins:int = 0;		protected var _health:int = 0;        protected var _maxHealth:int = 0;		protected var _dead:Boolean = false;        protected var _bountyCoins:int = 200;        protected var _bountyPayable:Object = null;        protected var _gameStats:Object = new Object();		protected var _foreGuard:Fighter;		protected var _rearGuard:Fighter;        protected var _ai:AIBehaviour;		protected var _movement:PlayerMovement;        public function get ai():AIBehaviour {            return _ai;        }		public function get playerData():PlayerData {			return _playerData;		}		public function get coins():int {			return _coins;		}		public function get health():int {			return _health;		}        public function get maxHealth():int {            return _maxHealth;        }		public function get dead():Boolean {			return _dead;		}		public function get foreGuard():Fighter {			return _foreGuard;		}		public function get rearGuard():Fighter {			return _rearGuard;		}		public function set coins(coins:int):void {			_coins = coins;		}		public function set health(health:int):void {			_health = health;		}        public function set maxHealth(value:int):void {            _maxHealth = value;        }        public function get movement():PlayerMovement {            return _movement;        }        public function get gameStats():Object {            return _gameStats;        }        public function Player(playerData:PlayerData=null) {			_playerData = playerData;            initMovement();            //TODO: Setup AI dynamically            if (_playerData.inputSource == NetScreen.AI_INPUT) {                _ai = new AIBehaviour(this);            }            //Initial game stats            _gameStats.playerKills = 0;            _gameStats.fighterKills = 0;            _gameStats.creepKills = 0;            _gameStats.totalCoins = 0;		}		public function update():void {            _movement.update();		}        public function teleportToTile(tile:BoardTile) {            if (this.stage) {                GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.TELEPORT_OUT, new Point(this.x, this.y),                                                         {tile:tile}, readyToTeleportHandler);            } else {                readyToTeleport(tile);            }        }        protected function readyToTeleportHandler(e:GameEvent):void {            readyToTeleport(e.data.tile);        }        protected function teleportMovement(tile:BoardTile):void {            if (!this.stage) {                GameBoard.getGameBoard().addChildToField(this);            }        }        protected function readyToTeleport(tile:BoardTile):void {            _movement.teleportToTile(tile);            GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.TELEPORT_IN, new Point(tile.x, tile.y),                                                     {teleportCallback:teleportMovement, tile:tile}, actionComplete);        }        public function boostMoveCount(boost:int):void {            _movement.moveCount += boost;            GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.BOOST_NOTIFICATION, new Point(this.x, this.y),                                                     {boostAmount:boost}, actionComplete);        }        public function giveCoins(numCoins:int):void {            _coins += numCoins;            _gameStats.totalCoins += numCoins;			GameInterface.getGameInterface().updatePlayerInterface(this);            if (numCoins > 0) {                GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.COINS_GAIN_NOTIFICATION,                                                new Point(this.x, this.y), {coinsGiven:numCoins}, coinsActionComplete);            } else {                dispatchEvent(new GameEvent(GameEvent.PLAYER_COINS_MODIFIED, {coinsGiven:numCoins}));             }        }        public function takeCoins(numCoins:int):void {            var negCoins:int = numCoins;            _coins -= numCoins;            if (_coins < 0) {                negCoins = numCoins + _coins;                _coins = 0;            }			GameInterface.getGameInterface().updatePlayerInterface(this);            if (negCoins > 0) {                GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.COINS_LOSS_NOTIFICATION,                                                new Point(this.x, this.y), {coinsTaken:negCoins}, coinsActionComplete);            } else {                dispatchEvent(new GameEvent(GameEvent.PLAYER_COINS_MODIFIED, {coinsTaken:negCoins}));            }        }        protected function coinsActionComplete(e:GameEvent):void {            dispatchEvent(new GameEvent(GameEvent.PLAYER_COINS_MODIFIED, e.data));             }        public function regenHealth(numHealth:int):int {            var healthAdded:Number = numHealth;            _health += numHealth;            if (_health > _maxHealth) {                healthAdded = numHealth + (_maxHealth - _health);                _health = _maxHealth;            }			GameInterface.getGameInterface().updatePlayerInterface(this);            if (healthAdded > 0) {                GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.HEALING_NOTIFICATION,                                                    new Point(this.x, this.y), {healing:healthAdded}, actionComplete);            }            return healthAdded;        }        protected function actionComplete(e:GameEvent=null):void {            dispatchEvent(new GameEvent(GameEvent.ACTION_COMPLETE));        }        public function shopForFighter():void {            GameInterface.getGameInterface().showDialogBox(DialogBox.SHOP_TIER_SELECT, {speaker: "Weapons Forge",                                                dialog: "Welcome!  We can make a weapon for you here.  You don't get " +                                                        "to choose what we make you, but the more you pay us, the " +                                                        "better a weapon we'll make! ",                                                player: this, costs: FighterFactory.TIER_PRICING},												                                                shopOrNot);        }        protected function shopOrNot(e:GameEvent):void {            var player:Player = e.data.dialogBoxData.player;            var tier:int = e.data.tier;            if (!tier) doneShopping();            else {                function fighterSelection(e:GameEvent):void {                    var newFighter:Fighter = FighterFactory.randomFighterFromTier(tier);                    var fighterSelection:FighterSelection = new FighterSelection(player, newFighter);                    GameEvent.addOneTimeEventListener(fighterSelection, GameEvent.ACTION_COMPLETE, doneShopping);                    GameInterface.getGameInterface().pushSuperScreen(fighterSelection);                }                GameEvent.addOneTimeEventListener(player, GameEvent.PLAYER_COINS_MODIFIED, fighterSelection);                player.takeCoins(FighterFactory.TIER_PRICING[tier-1]);            }        }        protected function doneShopping(e:GameEvent=null):void {            if (e != null) {                GameInterface.getGameInterface().dismissSuperScreen(e.target as Screen);            }            dispatchEvent(new GameEvent(GameEvent.ACTION_COMPLETE, this));        }        protected function calculateTotalUpkeep():int {            var totUpkeep:int = 0;            if (_foreGuard) totUpkeep += _foreGuard.upkeep;            if (_rearGuard) totUpkeep += _rearGuard.upkeep;            return totUpkeep;        }        public function takeUpkeepAndStartTurn():void {            GameEvent.addOneTimeEventListener(this, GameEvent.PLAYER_COINS_MODIFIED, upkeepTaken);            takeCoins(calculateTotalUpkeep());        }        protected function upkeepTaken(e:GameEvent):void {            var coinsTaken:int = e.data.coinsTaken;            if (coinsTaken < calculateTotalUpkeep()) {                removeFighter(true);                removeFighter(false);                GameInterface.getGameInterface().showDialogBox(DialogBox.DIALOG_ONLY,                                                        {player:this,                                                         dialog:"You didn't have enough coins to pay your upkeep!  " +                                                                "Your weapons have been liquidated."}, startTurn);            } else {                startTurn();            }        }        protected function startTurn(e:GameEvent=null):void {            dispatchEvent(new GameEvent(GameEvent.ACTION_COMPLETE));        }        protected function endTurn(e:GameEvent=null):void {            GameBoard.getGameBoard().endTurn();        }        //Fighter functions        public function setFighter(fighter:Fighter, onFront:Boolean):void {			var pos:Point;			if (onFront) {                removeFighter(onFront);				_foreGuard = fighter;				GameBoard.getGameBoard().addChildToField(_foreGuard);			} else {                removeFighter(onFront);				_rearGuard = fighter;				GameBoard.getGameBoard().addChildToField(_rearGuard);			}            fighter.addEventListener(GameEvent.FIGHTER_DIED, fighterKilled, false, 0, true);            _movement.updateFighters(_foreGuard, _rearGuard);			GameInterface.getGameInterface().updatePlayerInterface(this);		}        public function removeFighter(onFront:Boolean):void {            if (onFront && _foreGuard) {                GameBoard.getGameBoard().removeChildFromField(_foreGuard);                _foreGuard = null;            } else if (!onFront && _rearGuard) {                GameBoard.getGameBoard().removeChildFromField(_rearGuard);                _rearGuard = null;            }            _movement.updateFighters(_foreGuard, _rearGuard);			GameInterface.getGameInterface().updatePlayerInterface(this);        }        public function reverseFighters(reposition:Boolean=true):void {            var rearGuard:Fighter = _rearGuard;            _rearGuard = _foreGuard;            _foreGuard = rearGuard;			GameInterface.getGameInterface().updatePlayerInterface(this);            trace("SWITCHED FIGHTERS");            GameEvent.addOneTimeEventListener(_movement, GameEvent.ACTION_COMPLETE, actionComplete);            _movement.reverseFighters(reposition);        }        public function getForeGuard():Fighter {            return _foreGuard;        }        public function getRearGuard():Fighter {            return _rearGuard;        }        public function isFacingForward():Boolean {            return _movement.moveDirForward;        }        //Battle functions		public function damage(damage:int, fromFront:Boolean, fromCounter:Boolean):void {            var defender:Fighter = fromFront ? _foreGuard : _rearGuard;            var defense:int = 0;            if (defender) {                defense = defender.health;                function fighterDamageDone():void {                    var damageLeft:int = damage - defense;                    if (damageLeft > 0 && !fromCounter) {                        damagePlayerDirectly(damageLeft);                    } else {                        damageDone();                    }                }                GameEvent.addOneTimeEventListener(defender, GameEvent.DAMAGE_DONE, fighterDamageDone);                defender.damageFighter(damage);			    GameInterface.getGameInterface().updatePlayerInterface(this);            } else if (!fromCounter) {                damagePlayerDirectly(damage);            }		}        public function damagePlayerDirectly(damage:int):void {            _health -= damage;            if (_health <= 0) {                _health = 0;				kill();			}                        GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.DAMAGE_NOTIFICATION,                                                new Point(this.x, this.y), {damage:damage}, damageDone);			GameInterface.getGameInterface().updatePlayerInterface(this);        }        protected function damageDone(e:GameEvent=null):void {            dispatchEvent(new GameEvent(GameEvent.DAMAGE_DONE));        }        public function fighterKilled(e:GameEvent):void {            var fighter:Fighter = e.data as Fighter;            addToBountyPayable("coins", fighter.bountyCoins);            addToBountyPayable("fighterKills", 1);            if (fighter == _foreGuard) {                removeFighter(true);            } else {                removeFighter(false);            }		}		protected function kill():void {			_dead = true;            addToBountyPayable("coins", _bountyCoins);            addToBountyPayable("playerKills", 1);            _movement.kill();			dispatchEvent(new GameEvent(GameEvent.PLAYER_DIED, this));		}        public function payoutBounty():Object {            var bounty:Object = _bountyPayable;            _bountyPayable = null;            return bounty;        }        //Movement handlers        public function reverseMovement():void {            _movement.reverseMovement();            reverseFighters(false);        }        protected function initMovement():void {            _movement = new PlayerMovement(this);            _movement.updateFighters(_foreGuard, _rearGuard);            _movement.addEventListener(GameEvent.MOVEMENT_ENDED, endTurn, false, 0, true);            _movement.addEventListener(GameEvent.MOVEMENT_TILE_ACTIVATION, activatingTile, false, 0, true);            _movement.addEventListener(GameEvent.MOVEMENT_ARRIVED_AT_TILE, arrivedAtTile, false, 0, true);            _movement.addEventListener(GameEvent.MOVEMENT_DEPARTED_TILE, departedTile, false, 0, true);            _movement.addEventListener(GameEvent.MOVEMENT_REQUEST_NEXT_TILE, selectNextTile, false, 0, true);            _movement.addEventListener(GameEvent.MOVEMENT_ENEMY_ENCOUNTERED, enemyEncountered, false, 0, true);        }        protected function activatingTile(e:GameEvent):void {            if (e.data.onPass) {                e.data.tile.attemptActivateOnPass(this);            } else {                e.data.tile.activate(this);            }        }        protected function arrivedAtTile(e:GameEvent):void {            e.data.tile.arrive(this);        }        protected function departedTile(e:GameEvent):void {            e.data.tile.depart(this);        }        protected function selectNextTile(e:GameEvent):void {            e.data.tile.nextSequentialTile(this);        }        protected function enemyEncountered(e:GameEvent):void {            BattleManager.getBattleManager().startBattle(this, e.data.tile, battleFinished);        }        protected function battleFinished():void {            dispatchEvent(new GameEvent(GameEvent.BATTLE_FINISHED));        }        protected function addToBountyPayable(key:String, value:*):void {            if (_bountyPayable == null) _bountyPayable = new Object();            if (_bountyPayable[key] == null) _bountyPayable[key] = 0;            _bountyPayable[key] += value;        }	}}