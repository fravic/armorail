package septenary.duelparty {    import flash.display.DisplayObject;    import flash.display.DisplayObjectContainer;    import flash.events.MouseEvent;    import flash.geom.ColorTransform;    import flash.geom.Point;    import flash.ui.Keyboard;    import flash.utils.Dictionary;    public class FocusManager {        public static const MAIN_MANAGER_ID:String = "%MAIN_MANAGER_ID%";        protected static var _managersByID:Dictionary = new Dictionary();        protected var _id:String;        protected var _curFocusable:Focusable;        protected var _focusables:Array = new Array();        protected var _focusReference:DisplayObjectContainer;        public static function getManager():FocusManager {            var fm:FocusManager = getManagerByID(MAIN_MANAGER_ID);            return fm;        }        public static function getManagerByID(id:String):FocusManager {            //Convert to main manager id if this is the local player            if (!Singleton.get(NetworkManager).localPlayerNetID ||                 id == Singleton.get(NetworkManager).localPlayerNetID) id = MAIN_MANAGER_ID;            if (!_managersByID[id]) {                _managersByID[id] = new FocusManager(id);                if (id == MAIN_MANAGER_ID) {                    _managersByID[id].enableKeyboardInput();                }            }            return _managersByID[id];        }        public function FocusManager(id:String) {            _id = id;        }        public function get curFocusable():Focusable {            return _curFocusable;        }        public function focusableLeft():void {        	switchFocusToNearestInDirection(Math.PI);        }        public function focusableRight():void {            switchFocusToNearestInDirection(0);        }        public function focusableUp():void {            switchFocusToNearestInDirection(-Math.PI/2);        }        public function focusableDown():void {            switchFocusToNearestInDirection(Math.PI/2);        }        protected function focusableAction():void {            if (_curFocusable) _curFocusable.focusAction();        }        public function switchFocusToNearestInDirection(dirAngle:Number):void {            const baseAllowDirectDiff:Number = Math.PI/4;            const angleWeight:Number = 300;            var angleAllow:Number = baseAllowDirectDiff;            //Try to center around the current focusable            var centerPt:Point;            if (_curFocusable) {                centerPt = _curFocusable.localToGlobal(new Point(0, 0));            } else {                centerPt = _focusReference.localToGlobal(new Point(0, 0));            }            //Get the nearest focusable object in the direction specified            var nextFocusable:Focusable;            var closestDist:Number = Number.MAX_VALUE;            for (var i:int = 0; i < _focusables.length; i++) {                var f:Focusable = _focusables[i] as Focusable;                if (!f.focusEnabled) continue;                var fPt:Point = f.localToGlobal(new Point(0, 0));                if (f == _curFocusable || !f.visible) continue;                //Test direction                var direct:Number = Math.atan2(fPt.y - centerPt.y, fPt.x - centerPt.x);                var directDiff:Number = Utilities.angleDiff(direct, dirAngle);                //Test distance                var diffX:Number = centerPt.x - fPt.x;                var diffY:Number = centerPt.y - fPt.y;                var dist:Number = Math.sqrt((diffX * diffX) + (diffY * diffY));                                if (directDiff >= angleAllow) {                	dist += angleWeight * directDiff;                }                               if (dist < closestDist) {                    nextFocusable = f;                    closestDist = dist;                }            }            if (nextFocusable) switchFocus(nextFocusable);        }        public function switchFocusToNearest():void {            var minDist:Number = Number.MAX_VALUE;            var focusIndex:int = 0;            for (var i:int = 0; i < _focusables.length; i++) {                if (!_focusables[i].focusEnabled) continue;                var dist:Number = Math.sqrt(_focusables[i].x * _focusables[i].x + _focusables[i].y * _focusables[i].y);                if (dist < minDist) {                    minDist = dist;                    focusIndex = i;                }            }            switchFocus(_focusables[focusIndex]);        }        public function switchFocus(newFocus:Focusable):void {            if (_curFocusable) _curFocusable.lostFocus();            _curFocusable = newFocus;            if (newFocus != null) _curFocusable.gainedFocus();        }        public function registerFocusables(ref:DisplayObjectContainer):void {        	clearFocusablesInsideDisplay(ref);        	            _focusReference = ref;            registerFocusablesInsideDisplay(ref);						//Invalid: Can't set focus before listeners have been set.            //switchFocusToNearest();        }                protected function registerFocusablesInsideDisplay(disp:DisplayObjectContainer):void {            //Register ALL available focusables (recursively)            for (var i:int = 0; i < disp.numChildren; i++) {                var child:DisplayObject = disp.getChildAt(i);                if (child is Focusable && !(child is Screen)) {                    _focusables.push(child);                }else if (child is DisplayObjectContainer && !(child is Screen)) {                    registerFocusablesInsideDisplay(child as DisplayObjectContainer);                }            }        }        public function clearFocusablesInsideDisplay(disp:DisplayObjectContainer):void {			//Unregister ALL available focusables (recursively)			for (var i:int = 0; i < disp.numChildren; i++) {                var child:DisplayObject = disp.getChildAt(i);                if (child is Focusable && !(child is Screen)) {                    _focusables.splice(_focusables.indexOf(child), 1);                    if ((child as Focusable).hasFocus) {						switchFocusToNearest();					}                }else if (child is DisplayObjectContainer && !(child is Screen)) {                    clearFocusablesInsideDisplay(child as DisplayObjectContainer);                }            }        }                public function addFocusableListeners(f:Focusable, activateHandler:Function):void {        	f.addEventListener(MouseEvent.MOUSE_OVER, whiteFocusable, false, 0, true);			f.addEventListener(MouseEvent.MOUSE_OUT, unwhiteFocusable, false, 0, true);            f.addEventListener(MouseEvent.MOUSE_DOWN, blueFocusable, false, 0, true);            f.addEventListener(MouseEvent.MOUSE_UP, unblueFocusable, false, 0, true);			if (activateHandler != null) f.addEventListener(MouseEvent.MOUSE_UP, activateHandler, false, 0, true);            f.buttonMode = true;		}                public function removeFocusableListeners(f:Focusable, activateHandler:Function):void {        	f.removeEventListener(MouseEvent.MOUSE_OVER, whiteFocusable);			f.removeEventListener(MouseEvent.MOUSE_OUT, unwhiteFocusable);            f.removeEventListener(MouseEvent.MOUSE_DOWN, blueFocusable);            f.removeEventListener(MouseEvent.MOUSE_UP, unblueFocusable);			if (activateHandler != null) f.removeEventListener(MouseEvent.MOUSE_UP, activateHandler);            f.buttonMode = false;        }        public function addGeneralFocusableListener(disp:DisplayObjectContainer, activateHandler:Function):void {            for (var i:int = 0; i < disp.numChildren; i++) {                var obj:Object = disp.getChildAt(i);                if (obj is Focusable) {                    addFocusableListeners(obj as Focusable, activateHandler);                }            }            switchFocusToNearest();        }        public function removeGeneralFocusableListener(disp:DisplayObjectContainer,                                                              activateHandler:Function):void {            for (var i:int = 0; i < disp.numChildren; i++) {                var obj:Object = disp.getChildAt(i);                if (obj is Focusable) {                    removeFocusableListeners(obj as Focusable, activateHandler);                }            }        }        public function disableFocusable(f:Focusable):void {            f.mouseEnabled = false;            f.focusEnabled = false;            var ct:ColorTransform = f.transform.colorTransform;			ct.redOffset = ct.greenOffset = ct.blueOffset -= 60;			f.transform.colorTransform = ct;        }        public function disablePlayerInput(disp:DisplayObjectContainer):void {            disp.mouseEnabled = disp.mouseChildren = false;            if (_id == MAIN_MANAGER_ID) disableKeyboardInput();        }        public function enablePlayerInput(disp:DisplayObjectContainer):void {            disp.mouseEnabled = disp.mouseChildren = true;            if (_id == MAIN_MANAGER_ID) enableKeyboardInput();        }        protected function enableKeyboardInput():void {            KeyActions.addEventListener(Keyboard.LEFT, focusableLeft);            KeyActions.addEventListener(Keyboard.RIGHT, focusableRight);            KeyActions.addEventListener(Keyboard.UP, focusableUp);            KeyActions.addEventListener(Keyboard.DOWN, focusableDown);            KeyActions.addEventListener(Keyboard.SPACE, focusableAction);        }        protected function disableKeyboardInput():void {            KeyActions.removeEventListener(Keyboard.LEFT);            KeyActions.removeEventListener(Keyboard.RIGHT);            KeyActions.removeEventListener(Keyboard.UP);            KeyActions.removeEventListener(Keyboard.DOWN);            KeyActions.removeEventListener(Keyboard.SPACE);        }        		public function whiteFocusable(e:MouseEvent):void {			var ct:ColorTransform = e.target.transform.colorTransform;			ct.redOffset = ct.greenOffset = ct.blueOffset += 60;			e.target.transform.colorTransform = ct;		}        public function unwhiteFocusable(e:MouseEvent):void {			var ct:ColorTransform = e.target.transform.colorTransform;			ct.redOffset = ct.greenOffset = ct.blueOffset -= 60;			e.target.transform.colorTransform = ct;		}        public function blueFocusable(e:MouseEvent):void {            var ct:ColorTransform = e.target.transform.colorTransform;			ct.blueOffset += 30;			e.target.transform.colorTransform = ct;        }        public function unblueFocusable(e:MouseEvent):void {            var ct:ColorTransform = e.target.transform.colorTransform;			ct.blueOffset -= 30;			e.target.transform.colorTransform = ct;        }    }}