package septenary.duelparty {    import flash.events.EventDispatcher;	import playerio.*;	public class NetworkManager extends EventDispatcher {        private static const GUEST_ACCOUNT_ID:String = "guest";        private static const SERVER_TYPE:String = "bounce";        private static const ROOM_LIST_LIMIT:int = 50;		protected static var activeManager:NetworkManager;        protected var _activeConnection:Connection;        protected var _activeClient:Client;        CONFIG::RELEASE {            protected static const PLAYER_IO_GAME_ID:String = "armorail-yvvzcnzuue6on0gb458tgq";        }        CONFIG::DEBUG {            protected static const PLAYER_IO_GAME_ID:String = "armorail-staging-gd2zgihntugoxgb985fdlq";        }		public static function getNetworkManager():NetworkManager {            if (!activeManager) {                activeManager = new NetworkManager();            }			return activeManager;		}				public function NetworkManager() {            if (activeManager) Utilities.assert(false, "Double instantiation of singleton NetworkManager.");            //Register message types            NetworkMessage.registerMessageTypeArgs(NetworkMessage.JOIN, {numUsers:int, playerNetID:String});            NetworkMessage.registerMessageTypeArgs(NetworkMessage.DICE_ROLL, {playerNetID:String, roll:int});            NetworkMessage.registerMessageTypeArgs(NetworkMessage.DIR_SELECT, {playerNetID:String, dir:int});		}        /* LOGIN/ACCOUNT MANAGEMENT */        protected function login(userID:String, authKey:String=""):void {            PlayerIO.connect(				DuelParty.stage,				PLAYER_IO_GAME_ID,				"public",				userID,				authKey,				handleConnect,				handleConnectError				    			);        }                public function loginToFacebook(username:String, password:String):void {        }        public function loginAsGuest():void {            login(GUEST_ACCOUNT_ID);        }        protected function handleConnect(client:Client):void {            _activeClient = client;            trace("PLAYER.IO CONNECTED SUCCESSFULLY!");            dispatchEvent(new GameEvent(GameEvent.ACTION_COMPLETE, {success:true}));        }        protected function handleConnectError(error:PlayerIOError):void {            trace("PLAYER.IO ERROR: "+error);            dispatchEvent(new GameEvent(GameEvent.ACTION_COMPLETE, {success:true}));        }        /* ROOM MANAGEMENT */        protected function initConnection(connection:Connection):void {            Utilities.assert(_activeConnection == null, "A connection has already been initialized!");            _activeConnection = connection;            _activeConnection.addMessageHandler("*", handleMessages);        }        public function createRoom(numUsers:int):void {            Utilities.assert(_activeClient != null, "Cannot create room on inactive client!");            _activeClient.multiplayer.createJoinRoom(				"test",				SERVER_TYPE,				true,				{numUsers:numUsers},                {},				handleRoomCreate,				handleRoomCreateError								);        }        protected function handleRoomCreate(connection:Connection):void {            initConnection(connection);        }        protected function handleRoomCreateError(error:PlayerIOError):void {        }        public function joinRoom(roomInfo:RoomInfo):void {            Utilities.assert(_activeClient != null, "Cannot join room on inactive client!");            _activeClient.multiplayer.createJoinRoom(				"test",				SERVER_TYPE,				true,				{},                {},				handleRoomJoin,				handleRoomJoinError			);        }        protected function handleRoomJoin(connection:Connection):void {            initConnection(connection);        }        protected function handleRoomJoinError(error:PlayerIOError):void {        }        public function pollRooms(type:String):void {            _activeClient.multiplayer.listRooms(type, {}, ROOM_LIST_LIMIT, 0, roomPollComplete, handleConnectError);        }        public function roomPollComplete(rooms:Array):void {            dispatchEvent(new GameEvent(GameEvent.ACTION_COMPLETE, {rooms:rooms}));        }        /* MESSAGE MANAGEMENT */        public function sendMessage(type:String, data:Object):void {			Utilities.assert(_activeConnection != null, "Cannot send message to an inactive connection!");            var message:NetworkMessage = new NetworkMessage(type, data);            var argsArray:Array = [type].concat(message.serializedData);            _activeConnection.send.apply(_activeConnection, argsArray);        }        protected function handleMessages(m:Message){			trace("PLAYER.IO RECIEVED MESSAGE:", m);            var netMessage:NetworkMessage = new NetworkMessage(m.type);            netMessage.deserializeMessage(m);            dispatchEvent(new GameEvent(GameEvent.NETWORK_MESSAGE, {type:m.type, netData:netMessage.data,                                                                    messageSource:m}));		}		protected function handleDisconnect():void{		}	}}