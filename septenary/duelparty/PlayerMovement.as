package septenary.duelparty {    import com.greensock.TweenLite;    import flash.display.Sprite;    import flash.geom.Point;    import flash.events.EventDispatcher;    public class PlayerMovement extends FightableMovement {        protected static const FIGHTER_SPACING:Number = 20;		protected static const MOVE_SPEED:Number = 180;        protected var _prevTile:BoardTile;        protected var _movesLeftCounter:MovesLeftCounter;        protected var _moveCount:int = 0;        protected var _moveDirForward:Boolean = true;        public function get moveDirForward():Boolean {			return _moveDirForward;		}        public function get moveCount():int {            return _moveCount;        }        public function set moveCount(value:int):void {            hideMovesLeftCounter();            _moveCount = value;        }        public function PlayerMovement(player:Player):void {            super(player);        }        public override function kill():void {            super.kill();            _moveDirForward = true;        }        public function switchFighters(reposition:Boolean=true):void {            //Makes the foreguard the rearguard, and vice-versa        }        public function reverseMovement():void {            //Switches movement direction, and rotates everyone to face it			_moveDirForward = !_moveDirForward;		}		public function move(moveCount:int):void {			_moveCount = moveCount;			progress();		}		public function progress():void {            showMovesLeftCounter();            GameEvent.addOneTimeEventListener(_currentTile, GameEvent.ACTION_COMPLETE, nextTileSelected);            dispatchEvent(new GameEvent(GameEvent.MOVEMENT_REQUEST_NEXT_TILE, {tile:_currentTile}));		}		protected function nextTileSelected(e:GameEvent):void {            var nextTile:BoardTile = e.data.tile;			_prevTile = _currentTile;			_currentTile = nextTile;			prepareForMovement();		}		protected function prepareForMovement():void {			//Back up train and move to new path if necessary (if next tile is not default)			if (_currentTile != _prevTile.getTilesInDir(_moveDirForward)[0]) {                _manager.moveTo(new Point(_currentTile.x, _currentTile.y), preparedToMove);			} else {				preparedToMove();			}		}		protected function preparedToMove():void {			//Check for battle!			if (_currentTile.hasResidents()) {                hideMovesLeftCounter();                GameEvent.addOneTimeEventListener(_display, GameEvent.BATTLE_FINISHED, progressMovementStart);                dispatchEvent(new GameEvent(GameEvent.MOVEMENT_ENEMY_ENCOUNTERED, {tile:_currentTile}));			} else {				progressMovementStart();			}		}		protected function progressMovementStart(e:GameEvent=null):void {			const fighterPrepTime:Number = .15;            super.arrivedAtNewTile(_currentTile);            showMovesLeftCounter();            _manager.moveTo(new Point(_currentTile.x, _currentTile.y), progressMovementAdvance);		}        protected function progressMovementAdvance(e:GameEvent=null):void {            if (_carAhead != null) {    //Only if foreguard exists                var nextTile:BoardTile = _currentTile.getTilesInDir(_moveDirForward)[0];                var mvAngle:Number = Math.atan2(nextTile.y - _currentTile.y, nextTile.x - _currentTile.x);                var mvPt:Point = new Point(_currentTile.x + Math.cos(mvAngle) * FIGHTER_SPACING,                                           _currentTile.y + Math.sin(mvAngle) * FIGHTER_SPACING);                _manager.moveTo(mvPt, progressMovementEnd);            } else {                progressMovementEnd();            }        }		protected function progressMovementEnd():void {            super.departedCurrentTile(_prevTile);            if (_currentTile.reducesMoveCount) {				_moveCount--;                hideMovesLeftCounter();			}            GameEvent.addOneTimeEventListener(_currentTile, GameEvent.ACTION_COMPLETE, tileActivationComplete);            dispatchEvent(new GameEvent(GameEvent.MOVEMENT_TILE_ACTIVATION,                                       {player:_display, tile:_currentTile, onPass:(_moveCount > 0)}));		}		public function tileActivationComplete(e:GameEvent):void {			if (_moveCount > 0) {				progress();			} else {                dispatchEvent(new GameEvent(GameEvent.MOVEMENT_ENDED));			}		}        public override function update():void {            super.update();            if (_movesLeftCounter) {                var pos:Point = positionForMovesLeftCounter();                _movesLeftCounter.x = pos.x;                _movesLeftCounter.y = pos.y;            }        }        protected function showMovesLeftCounter():void {            if (!_movesLeftCounter) {                _movesLeftCounter = GUIAnimationFactory.createAndAddAnimation(GUIAnimationFactory.MOVES_LEFT_COUNTER,                                       positionForMovesLeftCounter(), {movesLeft:_moveCount}, null) as MovesLeftCounter;            }        }        protected function hideMovesLeftCounter():void {            if (!_movesLeftCounter) return;            GameBoard.getGameBoard().removeChildFromOverlay(_movesLeftCounter);            _movesLeftCounter = null;        }        protected function positionForMovesLeftCounter():Point {            const yOffset:Number = 40;            return new Point(_display.x, _display.y - yOffset);        }        public function positionForForeGuard():Point {			var defNextTile:BoardTile = _currentTile.getTilesInDir(_moveDirForward)[0];			var rot:Number = Math.atan2(defNextTile.y - _currentTile.y, defNextTile.x - _currentTile.x);			return new Point(_currentTile.x + FIGHTER_SPACING * Math.cos(rot), _currentTile.y + FIGHTER_SPACING * Math.sin(rot));		}		public function positionForRearGuard():Point {			var rot:Number = 0;            var prevTile:BoardTile = _prevTile;			if (!prevTile) {				prevTile = _currentTile.getTilesInDir(!_moveDirForward)[0];			}			if (!prevTile) {				prevTile = _currentTile.getTilesInDir(_moveDirForward)[0];				rot = Math.PI;			}			rot += Math.atan2(_currentTile.y - prevTile.y, _currentTile.x - prevTile.x);			return new Point(_currentTile.x + FIGHTER_SPACING * Math.cos(rot + Math.PI),                             _currentTile.y + FIGHTER_SPACING * Math.sin(rot + Math.PI));		}    }}