package septenary.duelparty {	import flash.geom.Point;    import flash.geom.Rectangle;	import flash.utils.getDefinitionByName;	public class Utilities {        /* Math Helpers: General */		public static const RADS_TO_DEG:Number = 180 / Math.PI;        public static function roundToDecimals(n:Number, d:int):Number {			var f:Number = Math.pow(10, d);			return Math.round(n * f) / f;		}		public static function sign(n:Number):int {			return n >= 0 ? 1 : -1;		}        public static function randomBounded(min:Number, max:Number):Number {            return Math.random() * (max - min) + min;        }		public static function asciiCodeFromNum(n:int):int {			return n + 48;		}        /* Math Helpers: Angles */        public static function randomPointOnCircle(r:Number):Point {			var theta:Number = Math.random() * (2 * Math.PI);			return new Point(r * Math.cos(theta), r * Math.sin(theta));		}		public static function normalizeDegAngle(a:Number):Number {			while (a < 0)				a += 360;			while (a > 360)				a -= 360;			return a;		}        public static function normalizeRadAngle(a:Number):Number {			while (a < 0)				a += 2 * Math.PI;			while (a >= 2 * Math.PI)				a -= 2 * Math.PI;			return a;		}		public static function angleDiff(a:Number, b:Number):Number {			var norm:Number = normalizeRadAngle(Math.abs(a - b));			if (norm > Math.PI) {				return 2 * Math.PI - norm;			} else {				return norm;			}		}        public static function shortRotation(from:Number, to:Number):int {            assert(from - to < 2 * Math.PI && from - to > -2 * Math.PI, "Attempt to short unormalized angles!");            var big:Number = Math.max(from, to);            var small:Number = Math.min(from, to);            var clkDist:Number = big - small;            var cntDist:Number = 2 * Math.PI - big + small;            if (clkDist < cntDist) {                if (small == from) {                    return 1;                } else {                    return -1;                }            } else {                if (small == from) {                    return -1;                } else {                    return 1;                }            }        }        /* Math Helpers: Points */        public static function magnitude(pt:Point):Number {			return Math.sqrt(pt.x * pt.x + pt.y * pt.y);		}		public static function magSquared(pt:Point):Number {			return pt.x * pt.x + pt.y * pt.y;		}        public static function pointFromString(s:String):Point {			var nums:Array = s.match(/\d+(.\d+)*/g);			if (!nums || nums.length != 2)				return null;			return new Point(Number(nums[0]), Number(nums[1]));		}        public static function keepPointInBounds(pt:Point, bounds:Rectangle):void {            if (pt.x < bounds.x) {				pt.x = bounds.x;			} else if (pt.x > bounds.width) {				pt.x = bounds.width;			}			if (pt.y < bounds.y) {				pt.y = bounds.y;			} else if (pt.y > bounds.height) {				pt.y = bounds.height;			}        }        /* Object Parsing and Modification */		public static function classInstanceFromString(s:String):* {			var newClass:Class = getDefinitionByName(s) as Class;			return new newClass();		}		public static function parseXMLValue(val:XML):* {			//Parse string			var str:String = val.toString();			//Parse numeric			var num:Number = Number(str);			if (!isNaN(num))				return num;			//Parse boolean			if (str == "true")				return true;			if (str == "false")				return false;			//Parse point			var pt:Point = pointFromString(str);			if (pt)				return pt;			return str;		}        public static function rocket(targ:Object, src:Object, props:Array):void {            //Copies all properties in props from src object to target object            for (var i:int = 0; i < props.length; i++) {                if (src[props[i]]) targ[props[i]] = src[props[i]];            }        }        /* Logging and Debugging */        public static function assert(cond:Boolean, message:String="General assertion."):void {            CONFIG::DEBUG {                if (!cond) {                    throw new Error("Assertion Failed: " + message);                }            }        }        public static function logx(x:String, ...rest):void {            CONFIG::DEBUG {                trace(x, rest);            }        }	}}