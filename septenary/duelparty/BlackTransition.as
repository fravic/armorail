package septenary.duelparty {    import flash.display.MovieClip;    import flash.display.BitmapData;    import flash.display.Bitmap;    import flash.geom.ColorTransform;    import flash.geom.Matrix;    import flash.geom.Rectangle;    import flash.geom.Point;    import flash.utils.setTimeout;	import com.greensock.TweenLite;		public class BlackTransition extends Screen {        public static const TRANSITION_SHAPE_CIRCLE:String = "TransitionShapeCircle";				protected static var _activeTransition:BlackTransition;        protected var _masked:MovieClip;		public static function getBlackTransition():BlackTransition {			return _activeTransition;		}		public function BlackTransition() {            _alwaysOnTop = true;			_activeTransition = this;		}        public function setMasked(masked:MovieClip):void {            if (_masked != null && _masked.mask != null) removeMask();            _masked = masked;            }				public function transition(inShape:String, outShape:String):void {			const transTime:Number = 0.7;			const smallScale:Number = 0.01;            var inMask:MovieClip = addMask(inShape);			TweenLite.to(inMask, transTime, {scaleX:smallScale, scaleY:smallScale, onComplete:transitionInDone,                                              onCompleteParams:[outShape]});		}				protected function transitionInDone(outShape:String):void {            const transDelay:Number = 0.8 * 1000;            const offScreen:Number = -100000;            getChildAt(0).x = offScreen;            setTimeout(transitionOut, transDelay, outShape);		}        protected function transitionOut(outShape:String):void {			const transTime:Number = 0.7;                        var outMask:MovieClip = addMask(outShape, false);            var finalSize:Number = getMaskLargeSize(outShape);            TweenLite.to(outMask, transTime, {scaleX:finalSize, scaleY:finalSize, onComplete:transitionOutDone});            dispatchEvent(new GameEvent(GameEvent.SCREEN_TRANSITIONED));        }				protected function transitionOutDone():void {            const transDelay:Number = 1 * 1000;            removeMask();            function actionComplete():void {                dispatchEvent(new GameEvent(GameEvent.ACTION_COMPLETE));            }            setTimeout(actionComplete, transDelay);		}        protected function addMask(shape:String, startLarge:Boolean=true):MovieClip {			const smallScale:Number = 0.01;            removeMask();			var newMask:MovieClip = Utilities.classInstanceFromString(shape);			newMask.x = DuelParty.stageWidth/2;            newMask.y = DuelParty.stageHeight/2;            _masked.mask = newMask;			addChild(newMask);            if (startLarge) {                var size:Number = getMaskLargeSize(shape);                newMask.scaleX = newMask.scaleY = size;            } else {                newMask.scaleX = newMask.scaleY = smallScale;            }                        return newMask;		}        protected function removeAllChildren():void {            while (numChildren > 0) removeChildAt(0);        }        protected function removeMask():void {            _masked.mask = null;            removeAllChildren();        }        protected function getMaskLargeSize(shape:String):Number {			var testMask:MovieClip = Utilities.classInstanceFromString(shape);            return Math.max(DuelParty.stageWidth/testMask.outline.width, DuelParty.stageHeight/testMask.outline.height);        }	}}